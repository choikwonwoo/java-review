### 상속

기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

상속 해주는 클래스 : 조상 클래스, 부모 클래스, 상위 클래스, 기반 클래스

상속 받는 클래스 : 자손 클래스, 자식 클래스, 하위 클래스, 파생된 클래스

```java
class 자손클래스 extends 조상클래스
```

- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
- 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

### 포함

한 클래스의 멤버 변수로 다른 클래스 타입의 참조변수를 선언하는 것, 상속과 마찬가지로 기존의 클래스를 재사용하기 위해 사용한다.

### 상속과 포함의 구분

- ~은 ~이다 (is a~) → 상속
- ~은 ~을 가지고 있다(has a~) → 포함

### toString()

참조변수의 출력이나 덧셈연산자를 이용한 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치한 후 처리한다.

toString()은 모든 클래스의 조상인 Object클래스에 정의된 것으로 어떤 종류의 객체에 대해서도 toString()을 호출하는 것이 가능하다.

### 단일 상속

자바는 둘 이상의 클래스로부터 상속을 받을 수 없다.

### 오버라이딩(overriding)

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와

- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환타입이 같아야 한다.

조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때

- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
- 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.

### super, super()

[this, this()](https://www.notion.so/06-d0719688b84f4a5c82e22686f58b8e14)와 비슷한 용도로 사용된다.

**super** : 상속받은 멤버와 자신의 멤버의 이름이 같을 때 사용한다.

**super()** : 조상 클래스의 생성자를 호출하는 데 사용한다.

Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 this() 또는 super()를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 ‘super();’를 생성자의 첫줄에 삽입한다.

## package와 import

### 패키지

클래스와 인터페이스의 묶음

- 하나의 소스파일에는 첫 번재 문장으로 단 한 번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일 (.class)을 포함하는 하나의 디렉토리이다.

```java
package 패키지명;
```

### import문

```java
1. package문
2. import문 //여러 번 선언 가능
3. 클래스 선언

import 패키지명.클래스명;
or
import 패키지명.*;  //한 패키지 안의 여러 클래스를 사용할 때
import java.lang.*; //lang패키지는 따로 import 하지 않아도 자동 import된다.

import static 패키지명.클래스명; //static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.
```

## 제어자 (modifier)

클래스, 변수 또는 메서드의 선언부에 함께 사용되어  부가적인 의미를 부여한다.

하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하지만 접근제어자는 한번에 하나만 쓸 수 있다.

### static

| 대상 | 의미 |
| --- | --- |
| 멤버변수 | - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.
- 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
- 클래스가 메모리에 로드될 때 생성된다. |
  | 메서드 | - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
- static메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다. |

### final

| 대상 | 의미 |
| --- | --- |
| 클래스 | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다. 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다. |
| 메서드 | 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다. |
| 멤버변수, 
지역변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다. |

### abstract

| 대상 | 의미 |
| --- | --- |
| 클래스 | 클래스 내에 추상 메서드가 선언되어 있음을 의미한다. |
| 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다. |

### 접근 제어자(access modifier)

외부로부터 데이터를 보호하고, 외부에는 불필요한 부분을 감추기 위해서 사용한다.

접근 제어자가 없다면 default임을 뜻한다.

**private :**  같은 클래스 내에서만

**default :**  같은 패키지 내에서만

**protected :**  같은 패키지 내에서, 다른 패키지의 자손 클래스에서

**public :**  접근 제한이 전혀 없다.

| 대상 | 사용가능한 접근 제어자 |
| --- | --- |
| 클래스 | public, default |
| 메서드,
멤버 변수 | public, protected, default, private |
| 지역변수 | 없음 |
1. 메서드에 static과 abstract를 함께 사용할 수 없다.
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
3. abstract메서드의 접근 제어자가 private일 수 없다.
4. 메서드에 private과 final을 같이 사용할 필요는 없다.

## 다형성 (polymorphism)

여러 가지 형태를 가질 수 있는 능력

조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있다.

다만, 조상 클래스 타입의 참조변수로는 자손클래스의 멤버에 접근할 수 없다.

따라서 실제 인스턴스와 같은 타입의 참조 변수로 형변환을 해야 인스턴스의 모든 멤버들을 사용할 수 있다.

```java
Tv t = new CaptionTv();

CaptionTv c = new CaptionTv();
Tv t = (Tv)c;
```

반대로, 자손클래스 타입의 참조변수로 조상클래스의 인스턴스를 참조할 수는 없다.

### 참조변수의 형변환

참조 변수의 형변환을 통해서 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절 할 수 있다.

자손타입 → 조상타입 (Up-casting)      : 형변환 생략가능

조상타입 → 자손타입 (Down-casting) : 형변환 생략불가

```java
(형변환 할 클래스)객체;
```

### instanceof연산자

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용된다.

instanceof를 이용한 연산결과가 true라는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

```java
객체 instanceof 클래스
```

### 참조변수와 인스턴스의 연결

조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스 변수를 자손 클래스에 중복으로 정의했을 때 참조변수의 타입에 따라 결과가 달라진다.

조상 타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고,

자손 타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.

메서드의 경우는 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드가 호출된다.

### 여러 종류의 객체를 배열로 다루기

조상타입의 참조변수 배열을 사용하여 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.

### Vector클래스

| 메서드 / 생성자 | 설명 |
| --- | --- |
| Vector() | 10개의 객체를 저장할 수 있는 Vector 인스턴스를 생성한다.
10개 이상의 인스턴스가 저장되면, 자동적으로 크기가 증가된다. |
| boolean add(Object o) | Vector에 객체를 추가한다. 추가에 성공하면 결과값으로 true, 실패하면 false를 반환한다. |
| boolean remove(Object o) | Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false를 반환한다. |
| boolean isEmpty() | Vector가 비어있는지 검사한다. 비어있으면 true, 비어있지 않으면 false를 반환한다. |
| Object get (int index) | 지정된 위치(index)의 객체를 반환한다. 반환타입이 Object타입이므로 적절한 타입으로의 형변환이 필요하다. |
| int size() | Vector에 저장된 객체의 개수를 반환하 |

[예제](https://www.notion.so/80b96eb863004644983ce8995d748add)

## 추상 클래스 ([abstract](https://www.notion.so/07-cf2413ba9c5e45869dc5aaf992eee49f) class)

추상클래스에는 멤버변수, 생성자, 추상메서드, 일반메서드가 사용된다.

추상메서드가 없어도 추상클래스로 지정할 수 있다. 객체 생성을 제한할 때 사용한다.

**추상메서드 선언**

```java
abstract 리턴타입 메서드이름();
```

추상메서드로 선언하면 메서드의 구현부를 빈 몸통{}으로 만들어 놓은 것과는 달리 자손클래스에서 추상메서드를 반드시 구현하도록 강요된다.

## 인터페이스 (interface)

추상클래스보다 추상화 정도가 높아 오직 추상메서드와 상수만을 멤버로 가질 수 있다.

```java
interface 인터페이스 이름 {
			public static final 타입 상수이름 = 값;
			public abstract 메서드 이름(매개변수목록)
```

모든 멤버에 제어자가 적용되기 때문에 제어자는 생략 가능하다.

*JCK1.8부터 인터페이스에 static메서드와 디폴트 메서드의 추가를 허용하는 방향으로 변경되었다.

```kotlin
public interface 인터페이스이름 {
			default void test() {
						System.out.println("test");
			}
}
```

클래스와 달리 다중상속이 가능하고, 상속과 구현을 동시에 할 수도 있다.

인터페이스끼리는 상속이 가능하다.

```java
class 클래스이름 implements 인터페이스이름

class 클래스이름 implements 인터페이스이름, 인터페이스이름, ...

class 자손클래스 extends 조상클래스 implements 인터페이스 
```

그러나 인터페이스로는 구현되어야할 메서드나 상수를 상속받을 뿐이기 때문에

두 개의 클래스로부터 상속을 받아야 할 상황이라면,

두 조상클래스 중에서 비중이 높은 쪽을 상속 받고,  다른 한 쪽은 클래스 내부에 멤버로 포함시키는 방식으로 처리하거나, 어느 한 쪽의 필요한 부분을 뽑아서 인터페이스로 만든 다음 구현하도록 한다.

```java
public class TV {
       ...
} 

public class VCR {
		...
		public void play() { ... }
		public void stop() { ... }
}

public interface IVCR {
		public void play();
		public void stop();
}

public class TVCR extends Tv implements IVCR{
		VCR vcr = new VCR();
		public void play() {
				vcr.play()
		}
		public void stop() {
				ver.stop()
		}
```

### 인터페이스를 이용한 다형성

인터페이스 타입의 참조변수도 구현클래스의 인스턴스를 참조할 수 있고

인터페이스 타입으로 형변환 하는 것도 가능하다.

따라서 인터페이스 타입의 매개변수를 사용할 수 있는데, 이는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다는 것이다.

리턴타입을 인터페이스 타입으로 지정하는 것도 가능하다, 이는 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.

### 인터페이스의 장점

- 개발시간을 단축시킬 수 있다.
- 표준화가 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.
- 독립적인 프로그래밍이 가능하다.

## 내부 클래스 (inner class)

클래스 안의 클래스

- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
- 코드의 복잡성을 줄일 수 있다. (캡슐화)

### 내부 클래스의 종류와 특징eeeeeeee

| 인스턴스 클래스 | 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다. |
| --- | --- |
| 스태틱 클래스 | 외부클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. |
| 주로 외부클래스의 static멤버, 특히 static 메서드에서 사용될 목적으로 선언된다. |  |
| 지역 클래스 | 외부 클래스의 메서드나 초기화 블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다. |
| 익명 클래스 | 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스 (일회용) |

| 내부 클래스 | 특징 |
| --- | --- |
| 인스턴스 클래스 | 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다. |
| 스태틱 클래스 | 외부클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 
주로 외부클래스의 static멤버, 특히 static 메서드에서 사용될 목적으로 선언된다. |
| 지역 클래스 | 외부 클래스의 메서드나 초기화 블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다. |
| 익명 클래스 | 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스 (일회용) |

### 익명클래스
```java
new 조상클래스 이름() {
//멤버 선언
}
new 구현인터페이스 이름() {
//멤버 선언
}